var CryptoJS = require('crypto-js');
var crypto = require('crypto');
var jwtEncrypted  = require('jsonwebtoken');
var jwtDecode = require('jwt-decode');

const algorithm = 'aes-256-cbc';

const duration = {
  ONE_DAY: '24h',
  TWO_DAYS: '2 days',
  DISABLED: 0,
};

module.exports = {
    duration,
    encrypt: (data = {}, jwtKey, dur = duration.DISABLED) => {
      try {
        if (typeof data !== 'object') throw new Error('data should be object');
        if (typeof dur === 'number' || dur === duration.ONE_DAY || dur === duration.TWO_DAYS) {
          const key = crypto.randomBytes(32);
          const iv = crypto.randomBytes(16);
          let cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);
          let encrypted = cipher.update(JSON.stringify(data));
          encrypted = Buffer.concat([encrypted, cipher.final()]);
          const token = jwtEncrypted.sign({
            iv: iv.toString('hex'),
            encrypted: encrypted.toString('hex'),
            key,
          }, jwtKey, { expiresIn: dur });
          return token;
        }
        throw new Error('duration should be milisecond or static path');
      } catch (error) {
        throw new Error(error.message);
      }
    },
    decrypt: (encrypted) => {
      try {
        const encryptedData = jwtDecode(encrypted);
        if (!encryptedData.iv) throw new Error('iv not found');
        if (!encryptedData.encrypted) throw new Error('encrypted not found');
        let iv = Buffer.from(encryptedData.iv.toString('hex'), 'hex');
        let encryptedText = Buffer.from(encryptedData.encrypted, 'hex');
        let decipher = crypto.createDecipheriv(algorithm, Buffer.from(encryptedData.key), iv);
        let decrypted = decipher.update(encryptedText);
        decrypted = Buffer.concat([decrypted, decipher.final()]);
        return JSON.parse(decrypted.toString());
      } catch (error) {
        throw new Error(error.message);
      }
    }
}
